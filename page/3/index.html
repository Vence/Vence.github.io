<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>王文路的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="王文路的博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="王文路的博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="王文路的博客">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="王文路的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://i2.piimg.com/62a5ce5907610d14.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">王文路</a></h1>
		</hgroup>

		
		<p class="header-subtitle">自弃者扶不起，自强者击不倒</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/about">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://github.com/Vence" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/my0love" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/aop/" style="font-size: 10px;">aop</a> <a href="/tags/backbone/" style="font-size: 12.5px;">backbone</a> <a href="/tags/blog/" style="font-size: 12.5px;">blog</a> <a href="/tags/cluster/" style="font-size: 12.5px;">cluster</a> <a href="/tags/file/" style="font-size: 12.5px;">file</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/hibernate/" style="font-size: 10px;">hibernate</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/mail/" style="font-size: 10px;">mail</a> <a href="/tags/mybatis/" style="font-size: 12.5px;">mybatis</a> <a href="/tags/myeclipse/" style="font-size: 10px;">myeclipse</a> <a href="/tags/octopress/" style="font-size: 10px;">octopress</a> <a href="/tags/patent/" style="font-size: 20px;">patent</a> <a href="/tags/permission/" style="font-size: 10px;">permission</a> <a href="/tags/recource/" style="font-size: 10px;">recource</a> <a href="/tags/requirejs/" style="font-size: 10px;">requirejs</a> <a href="/tags/spring/" style="font-size: 17.5px;">spring</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/web/" style="font-size: 17.5px;">web</a> <a href="/tags/webservice/" style="font-size: 12.5px;">webservice</a> <a href="/tags/压力测试/" style="font-size: 12.5px;">压力测试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">生命就像那空中白色的羽毛，或迎风搏击，或随风飘荡，或翱翔蓝天，或坠入深渊...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王文路</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://i2.piimg.com/62a5ce5907610d14.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">王文路</h1>
			</hgroup>
			
			<p class="header-subtitle">自弃者扶不起，自强者击不倒</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://github.com/Vence" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/my0love" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-backbone-info" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/14/backbone-info/" class="article-date">
  	<time datetime="2015-05-14T13:22:08.000Z" itemprop="datePublished">2015-05-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/14/backbone-info/">Backbone技术解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.css88.com/doc/backbone/" target="_blank" rel="external">Backbone</a>是一款前端MVC框架，对于前段开发人员，将会产生很多的便利，使得我们的前端代码更容易维护；但是无可否认，使用Backbone进行前端开发无疑增加了前端开发人员的工作量，因为了解并熟悉Backbone的机制是需要时间的。不过清晰的代码逻辑、高维护性依然使得很多项目采用了Backbone框架，对于稍微大一点的项目，前端业务逻辑可能比较复杂，代码组织可能比代码实现更加重要。</p>
<p>当然前端开发框架还有很多，比如更流行的RegularJS，比Backbone拥有更多的用户，不过Bakbone的小巧和灵活性依然是ResgularJS不能比较的。Backbone拥有更多的可能性，所以对于前端开发人员的技术要求更高一点，对于一个初次接触Backbone的童鞋来说，熟悉Backbone机制比什么都重要，不然写出的各种View和绑定事件一定会让你抓狂不已。</p>
<p>不幸的是Backbone没有告诉我们如何组织代码，让很多开发者对于如何加载所需脚本是比较迷茫的，所以将require与Backbone集成起来。require可以帮助我们轻松组织Backbone。</p>
<p>为了方便多个view的加载，我们使用requir.js与Backbone集成起来,关于require的内容，在上一章节中介绍过。</p>
<p>首先给大家看一下全球js库和框架的使用比例：</p>
<p><img src="http://i1.piimg.com/09633998bbe6c0d8.jpg" alt=""></p>
<p>这是通过搜索引擎抓取script标签统计而来的数据，可信度相当高啊，另外，不要迷恋Angular.js，Avalon.js还是挺不错的。</p>
<ul>
<li>什么是Backbone.js？</li>
<li></li>
</ul>
<p>Backbone.js是十大JS框架之首，Backbone.js 是一个重量级js MVC 应用框架，也是js MVC框架的鼻祖。它通过Models数据模型进行键值绑定及custom事件处理，通过模型集合器Collections提供一套丰富的API用于枚举功能，通过视图Views来进行事件处理及与现有的Application通过JSON接口进行交互。</p>
<p>简而言之，Backbone是实现了web前端MVC模式的js库</p>
<ul>
<li>什么是MVC？<br>-</li>
</ul>
<p><img src="http://i1.piimg.com/267f1debcf5b8776.jpg" alt=""></p>
<p><strong>MVC</strong>：后端服务器首先（过程1）通过浏览器获取页面地址，对网址进行解析，得到视图View给它的一个网址，然后通过控制器controller进行解析，然后去找对应的数据（过程2），找到数据后，再将数据Model返回给控制器（过程3），控制器controller再对数据进行加工，最后返回给视图（过程4），即更新视图View。这种结构在后端是非常清晰且易实现的</p>
<ul>
<li>Backbone中MVC的机制</li>
<li></li>
</ul>
<p>Backbone将数据呈现为模型, 你可以创建模型、对模型进行验证和销毁，甚至将它保存到服务器。 当UI的变化引起模型属性改变时，模型会触发”change”事件； 所有显示模型数据的视图会接收到该事件的通知，继而视图重新渲染。 你无需查找DOM来搜索指定id的元素去手动更新HTML。 — 当模型改变了，视图便会自动变化。———百度百科</p>
<p><em>模式：一种解决问题的通用方法</em></p>
<p> —设计模式：工厂模式、适配器模式和观察者模式</p>
<p> —框架模式：MVC、MVP、MVVM</p>
<p>控制器：通过控制器来连接视图与模型。</p>
<h3 id="MVC模式的思想"><a href="#MVC模式的思想" class="headerlink" title="MVC模式的思想"></a>MVC模式的思想</h3><p>就是把模型与视图分离，通过控制器来连接他们</p>
<p>服务器端MVC模式非常容易实现</p>
<p>Model：模型即数据，模型 是所有 js 应用程序的核心，包括交互数据及相关的大量逻辑： 转换、验证、计算属性和访问控制。你可以用特定的方法扩展 Backbone.Model</p>
<p>View：即你在页面上所能看到的视图。每一个单一的数据模型对应一个视图View</p>
<p>web页面本身就是一个很大的view，不太容易做到分离操作，backbone.js适合复杂的大型开发，并为我们解决了这些难题</p>
<h3 id="backbone的模块"><a href="#backbone的模块" class="headerlink" title="backbone的模块"></a>backbone的模块</h3><p>backbone有如下几个模块：</p>
<pre><code>Events：事件驱动模块
Model：数据模型
Collection：模型集合器
Router：路由器（对应hash值）
History：开启历史管理
Sync：同步服务器方式
View：视图（含事件行为和渲染页面 相关方法）
集合器Collection是对单独的数据模型进行统一控制
</code></pre><p>下面我们来详细说一下Backbone中各种常用的机制。</p>
<hr>
<ul>
<li>Model</li>
<li></li>
</ul>
<p>Backbone数据模型，是前端操作的分子数据单位，对应后台的一条记录，用来存储实际操作的数据。</p>
<pre><code>define([ &quot;backbone&quot; ], function(Backbone) {

var domain = Backbone.Model.extend({
    defaults : {
        id : null,      // ID
        name : null,    // 名称
        domainCode : null   //组织代码
    }
});
return domain;
});
</code></pre><p>这里需要依赖的模块是backbone，模型就是扩展Backbone的Model，并增加自己的属性，除此之外，Backbone还提供了关于model的事件监听，比如一下：</p>
<pre><code>var Task = Backbone.Model.extend({
initialize: function () {
    this.on(&quot;change:name&quot;, function (model) {
        alert(&quot;new name is : &quot; + model.get(&quot;name&quot;));
    });
}
});

var t = new Task({tid:&quot;3333&quot;, name:&quot;oooo&quot;, state:&quot;working&quot;});
t.set({name:&quot;xxx&quot;});
</code></pre><p>绑定了model的change事件，change事件可以指定属性，比如以上就只是绑定了name属性的change事件，在设置model的name的时候触发这个事件；不加的话，就是绑定了整个model的事件，model的任何一个属性改变都会触发这个事件。</p>
<h3 id="Model使用-fetch-方法从后台获取数据："><a href="#Model使用-fetch-方法从后台获取数据：" class="headerlink" title="Model使用 fetch 方法从后台获取数据："></a>Model使用 <strong>fetch</strong> 方法从后台获取数据：</h3><pre><code>var currUser = new UserModel();
BackBone.currUser.fetch({
        url : &quot;api/&quot; + sessionId + &quot;/users/currentuser&quot;,
        reset : true,
        wait : true,
        success : function(model, data) {},
        error : function(model, data) {
            window.location = &quot;login&quot;;
        }
    });
</code></pre><h3 id="Model用save新增和更新数据"><a href="#Model用save新增和更新数据" class="headerlink" title="Model用save新增和更新数据"></a>Model用save新增和更新数据</h3><p> 首次保存时(isNew)，会采用create方式(HTTP post)，已存在的model则只需要update方式(HTTP put)</p>
<pre><code>var p1 = new Person()
p1.save({name: &apos;Backus&apos;, age: 87}) // create
p1.save({name: &apos;John&apos;}) // update
</code></pre><p>可以传success和error两个回调函数以处理保存成功与失败的情况</p>
<pre><code>var p1 = new Person()
p1.save({name: &apos;Backus&apos;, age: 87}, {
    success: function() {},
    error: function() {}
})
</code></pre><h3 id="Model使用destory销毁："><a href="#Model使用destory销毁：" class="headerlink" title="Model使用destory销毁："></a>Model使用destory销毁：</h3><pre><code>// 1 删除当前model
    this.model.destroy({
            url : &quot;api/&quot; + sessionId + &quot;/schedules/&quot;,
            wait : true, 
            success : function(model, data){
            },
            error : function(model, data){
            }
        });
</code></pre><p>参数说明：</p>
<p><strong>reset</strong> : 当模型数据从服务器返回时， 它使用 set来（智能的）合并所获取到的模型， 除非你传递了 {reset: true}， 在这种情况下，集合将（有效地）重置。 </p>
<p><strong>wait</strong> : 创建一个模型将<em><font color="blue">立即</font></em>触发集合上的”add”事件， 一个”request”的事件作为新的模型被发送到服务器， 还有一个 “sync” ”事件，一旦服务器响应成功创建模型的时候触发。 如果你想在集合中添加这个模型前等待服务器相应，请传递{wait: true}。 </p>
<p><strong>sort</strong> : 强制对集合进行重排序。一般情况下不需要调用本函数，因为当一个模型被添加时， comparator 函数会实时排序。要禁用添加模型时的排序，可以传递{sort: false}给add。 调用sort会触发的集合的”sort”事件。 </p>
<hr>
<p>-Collection<br>-</p>
<p>Collection就是model的集合，需要指明model。</p>
<pre><code>define([ &quot;backbone&quot;, &quot;domainModel&quot; ],
    function(Backbone, DomainModel) {

        var collection = Backbone.Collection.extend({
            model : DomainModel
        });

        return collection;
    });
</code></pre><p>注意define中需要依赖model模块。</p>
<p>collection还提供了诸如比较排序的方法。</p>
<pre><code>var books =new Backbone.Collection(null, {
            model:Book,
            comparator:function(m1,m2){
                var price1 = m1.get(&apos;price&apos;);
                var price2 = m2.get(&apos;price&apos;);

                return price1 &gt; price2 ? 1:0;
            }    

        });
</code></pre><h3 id="Collection获取数据"><a href="#Collection获取数据" class="headerlink" title="Collection获取数据"></a>Collection获取数据</h3><pre><code>var collection = new UserCollection();
this.collection.fetch({
            url : &quot;api/&quot; + sessionId + &quot;/users&quot; ,
            reset : true,
            wait : true,
            success : function(collection, data) {

            },
            error : function(collection, data) {
                window.location = &quot;login&quot;;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
            }
        });
</code></pre><h3 id="Collection新增model"><a href="#Collection新增model" class="headerlink" title="Collection新增model"></a>Collection新增model</h3><pre><code>this.collection.create(schedule, {
                url:&quot;api/&quot;+ sessionId + &quot;/schedules/&quot; + this.templateId+&quot;/appointments&quot;,
                success : function(model , data){
                },
                error : function(model , data){

                },
                sort : true,
                wait : true
            });
</code></pre><p>collection还提供了快速查找，需要说明的是backbone强依赖于underscore，underscore提供了几十种高效精简的工具方法，比如collection的很多快速查找，遍历等方法都是基于underscore的。</p>
<h3 id="遍历collection"><a href="#遍历collection" class="headerlink" title="遍历collection"></a>遍历collection</h3><pre><code>this.collection.each(function(model){
} , this);
</code></pre><p>each的第二参数可以省略，当需要确定工作空间的时候，需要指明；<br>比如这里，each中的this，就是第二个参数确定的工作空间，如果不指明第二个参数的话，each中的this，不等同于each外的this.</p>
<h3 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h3><pre><code>var friends = new Backbone.Collection([
  {name: &quot;Athos&quot;,      job: &quot;Musketeer&quot;},
  {name: &quot;Porthos&quot;,    job: &quot;Musketeer&quot;},
  {name: &quot;Aramis&quot;,     job: &quot;Musketeer&quot;},
  {name: &quot;d&apos;Artagnan&quot;, job: &quot;Guard&quot;},
]);

var musketeers = friends.where({job: &quot;Musketeer&quot;});

alert(musketeers.length);
</code></pre><p>或者使用find</p>
<pre><code>var ret = this.collection.find(function(model , index){
if (model.get(&quot;name) = &quot;vence&quot;)
    return true;
});
</code></pre><p>find得到的返回就是查找的model对象，如果查找不到就是null；</p>
<ul>
<li>View<br>-</li>
</ul>
<p>Backbone 视图几乎约定比他们的代码多 — 他们并不限定你的HTML或CSS， 并可以配合使用任何JavaScript模板库。 一般是组织您的接口转换成逻辑视图， 通过模型的支持， 模型变化时， 每一个都可以独立地进行更新， 而不必重新绘制该页面。我们再也不必钻进 JSON 对象中，查找 DOM 元素，手动更新 HTML 了，通过绑定视图的 render 函数到模型的 “change” 事件 — 模型数据会即时的显示在 UI 中。 </p>
<pre><code>SearchView = Backbone.View.extend({

initialize: function(){

    this.render();

},

render: function() {

    //使用underscore这个库，来编译模板

    var template = _.template($(&quot;#search_template&quot;).html(),{});

    //加载模板到对应的el属性中

    this.el.html(template);

},

events:{  //就是在这里绑定的

    &apos;click input[type=button]&apos; : &apos;doSearch&apos;  //定义类型为button的input标签的点击事件，触发函数doSearch

},

doSearch: function(event){
    alert(&quot;search for &quot; + $(&quot;#search_input&quot;).val());
}

});

var searchView = new SearchView({el: $(&quot;#search_container&quot;)});
</code></pre><ul>
<li>Event<br>-</li>
</ul>
<p>Events 是一个可以融合到任何对象的模块, 给予 对象绑定和触发自定义事件的能力. Events 在绑定之前 不需要声明, 并且还可以传递参数. 比如: </p>
<pre><code>var object = {};

_.extend(object, Backbone.Events);

object.on(&quot;alert&quot;, function(msg) {
  alert(&quot;Triggered &quot; + msg);
});

object.trigger(&quot;alert&quot;, &quot;an event&quot;);
</code></pre><p>时间监听ListenTo</p>
<p>让 object 监听 另一个（other）对象上的一个特定事件。不使用other.on(event, callback, object)，而使用这种形式的优点是：listenTo允许 object来跟踪这个特定事件，并且以后可以一次性全部移除它们。callback总是在object上下文环境中被调用。</p>
<pre><code>this.listenTo(model, &apos;change&apos;, view.render);        // 监听模型变化事件
this.listenTo(collection, &quot;sync&quot; , this.handleSync);    // 监听collection获取事件
</code></pre><p>事件解绑</p>
<p>从 object 对象移除先前绑定的 callback 函数。如果没有指定context（上下文），所有上下文下的这个回调函数将被移除。如果没有指定callback，所有绑定这个事件回调函数将被移除；如果没有指定event，所有事件的回调函数会被移除。 </p>
<pre><code>// Removes just the `onChange` callback.
object.off(&quot;change&quot;, onChange);

// Removes all &quot;change&quot; callbacks.
object.off(&quot;change&quot;);

// Removes the `onChange` callback for all events.
object.off(null, onChange);

// Removes all callbacks for `context` for all events.
object.off(null, null, context);

// Removes all callbacks on `object`.
object.off();
</code></pre><p>基于Backbone自定义全局事件</p>
<pre><code>this.listenTo(Backbone, &quot;Schedule:AddSchedule&quot;, this.handleAddSchedule);
</code></pre><p>解绑<br>    Backbone.off(“Schedule:AddSchedule”);</p>
<p><em>使用Backbone进行前端开发，一定要注意培养一个良好的开发习惯，比如谁产生，谁销毁，事件绑定和解绑，绑定Dom事件的时机等等，具体我将在下一节进行探讨</em></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/backbone/">backbone</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-require-info" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/14/require-info/" class="article-date">
  	<time datetime="2015-05-14T04:22:32.000Z" itemprop="datePublished">2015-05-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/14/require-info/">使用RequireJS实现异步加载脚本</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关于Require的使用"><a href="#关于Require的使用" class="headerlink" title="关于Require的使用"></a>关于Require的使用</h2><p>因为 javascript 天生的缺点，语言本身没有集成命名空间的概念，所以变量名、函数名很容易发生冲突。大家想尽了各种办法，给 js 添加命名空间的概念，其中最成熟的套路，就是 RequireJS 这种。</p>
<p>总之，RequireJS 定义了(define)一个命名空间，在定义的时候，顺便引用了需要使用其他命名空间。我们注意到，按照 RequireJS 的术语，它把命名空间叫做“模块”。注意，在这里，RequireJS 定义的模块(命名空间)是匿名的，没有取名，这是和c#不同的地方。</p>
<p>但这个不要紧，因为其他 js 在用到你这个 js 的时候，一般是根据文件名称加载的，同时可以通过上面的 xx 这种方式，给模块(命名空间)自定义别名，所以，取不取名，还真不是关键。</p>
<hr>
<h3 id="Require配置"><a href="#Require配置" class="headerlink" title="Require配置"></a>Require配置</h3><p>页面中要加载require.js并指明主要入口文件。</p>
<pre><code>&lt;!--data-main=&quot;main&quot;，等号右边的main指的main.js,相当于入口--&gt;
&lt;script type=&quot;text/javascript&quot; data-main=&quot;&lt;%=path%&gt;/lib/main&quot; src=&quot;&lt;%=path%&gt;/lib/require.js&quot;&gt;&lt;/script&gt;
</code></pre><p>对于入口文件中作如下设置:</p>
<pre><code>require.config({
    urlArgs : &quot;timestamp=&quot; + (new Date()).getTime(),
    waitSeconds: 60,
    paths : {
            // 省略.......
        userModel:&quot;modules/userModel&quot;,
        userCollection:&quot;modules/userCollection&quot;
    },

    shim : {

        bootstrap : {
             deps : [ &quot;jquery&quot; ],
             exports : &quot;$.fn.popover&quot;
        },

    bootstrap_datetimepicker : {
         deps : [ &quot;jquery&quot;, &quot;bootstrap&quot; ],
         exports : &quot;$.fn.datetimepicker&quot;
    },

    jqueryIfrmdailog : {
        deps : [ &quot;jquery&quot; ],
        exports : &quot;$.ShowIfrmDailog&quot;
    },        
   }
});

var requirArray = [&quot;jquery&quot;, &quot;jqueryUI&quot;];

require(requirArray, function($, jqueryUI) {
    //
});
</code></pre><p>参数说明：</p>
<p><strong>baseUrl</strong>: 查找所有模块的根路径。</p>
<p><strong>urlArgs</strong> :RequireJS 用来匹配资源的额外的URL的查询参数 。通常的用法是在浏览器或者服务器配置不对的时候禁用缓存。</p>
<p><strong>waitSeconds</strong>: 放弃加载脚本前的等待的秒数。 设置为 0 则禁用此功能。默认是 7 秒。</p>
<p><strong>paths</strong>: 映射到不能直接在baseUrl下找到的模块名。 通常， path设置的路径是相对于baseUrl 的，除非 以 “/“ 开头或包含URL协议 (例如” http:”)。<font color="#4B0082">path的设置不要加.js后缀</font>，因为path也可能是映射到一个目录。 如果path映射的是一个模块，RequireJS会自动加上.js后缀。</p>
<p><strong>shim</strong>: 为那些没有使用define() 声明依赖项、没有设置模块值、老的、传统的”浏览器全局”脚本配置依赖项和exports。</p>
<p><strong>map</strong>: 对于给定的相同的模块名，加载不同的模块，而不是加载相同的模块。</p>
<p><strong>config</strong>: 传递一个配置信息到模块中是一个常见的需求。这个配置信息通常是应用的一部分，我们需要把它传递到模块中。 在 RequireJS 中，requirejs.config()中的config配置项 就是为了解决这个需求。 模块中可以通过内置依赖模块”module” ，通过调用module.config()方法来获取传递进来的配置信息.</p>
<p><strong>packages</strong>: 配置从CommonJS 包来加载模块.</p>
<p><strong>context</strong>: 加载上下文配置(require.config的对象)的名字。 只要顶级 require调用指定一个唯一context字符串，require.js就可以在一个页面中加载多个版本的模块。</p>
<p><strong>deps</strong>: 需要加载的依赖项的数组。当在require.js加载前使用全局 require对象来定义配置的时候很有用，也可以在require()一定义后就马上加载指定依赖项的时候用。</p>
<p><strong>callback</strong>: 所有依赖项加载后执行的回调函数。</p>
<p><strong>enforceDefine</strong>: 如果设置为true， 当加载的脚本是没用define()包装过，且在shim配置中没有配置exports值时会抛错。</p>
<p><strong>xhtml</strong>: 如果设置为 true，requireJS 将使用document.createElementNS() 来创建script标签。</p>
<p><strong>scriptType</strong>: 设置 RequireJS生成的 script 标签的 type属性值。默认是”text/javascript”。 </p>
<p>require关键字就是一个加载方法，加载的时候，可以定义别名；除了这种方法外，还可以用define，define是你定义自己的模块的时候使用，可以顺便加载其他的js。</p>
<hr>
<h3 id="define定义模块"><a href="#define定义模块" class="headerlink" title="define定义模块"></a>define定义模块</h3><pre><code>define([&quot;jquery&quot;], function($){

    var util = {};
    util._helper = {};

    // 日期格式化输出
    util._helper.dateFormat = function(date , fmt) { //author: meizz 

        if (date == null || ! (date instanceof Date)) {
            return &quot;&quot;;
        }

        var o = {
            &quot;M+&quot; : date.getMonth() + 1, //月份 
            &quot;d+&quot; : date.getDate(), //日 
            &quot;h+&quot; : date.getHours(), //小时 
            &quot;m+&quot; : date.getMinutes(), //分 
            &quot;s+&quot; : date.getSeconds(), //秒 
            &quot;q+&quot; : Math.floor((date.getMonth() + 3) / 3), //季度 
            &quot;S&quot; : date.getMilliseconds()
        //毫秒 
        };
        if (/(y+)/.test(fmt))
            fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &quot;&quot;)
                    .substr(4 - RegExp.$1.length));
        for ( var k in o)
            if (o.hasOwnProperty(k) &amp;&amp; new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt))
                fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));
        return fmt;
    };

    return util;
});
</code></pre><hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>路径与后缀名</p>
<p>  在 require 一个 js 文件的时候，一般不需要加上后缀名。如果加上后缀名，会按照绝对路径加载。没有后缀名，是按照下面的路径加载：</p>
</li>
</ul>
<ul>
<li><script data-main="js/main" src="js/require-jquery.js"></script><br>也就是默认加载 data-main 指定的目录，即 js/main.js 文件所在的目录。当然，你可以通过配置文件修改。</li>
</ul>
<ul>
<li>define 定义模块方法只能用在独立的js文件中，不能在页面中直接使用。<br>否则会报 Mismatched anonymous define() module 错误。</li>
</ul>
<ul>
<li><p>和其他第三方js类库是否冲突？</p>
<p>  不会冲突。一般比较规范的类库，都会给自己的js加上命名空间。比如 wojilu 旧有的 wojilu.common.js ，其实就是放在 wojilu 命名空间中(当然是通过更原始的方式实现命名空间的)。</p>
<p>  在通过 RequireJS 加载这些第三方的 js 的时候，完全不要有任何担忧。</p>
<p>  当然，如果第三方类库能够使用 RequireJS 的方式进行改造，那是最好。比如 wojilu 中大多数js 都按照 RequireJS 的方式进行了改造。但是，如果你不改造，也是完全不要紧的。</p>
</li>
</ul>
<ul>
<li><p>在代码中 require 一个文件多次，是否会导致浏览器反复加载？</p>
<p>  不会，这是 RequrieJS 的优点，即使你反复 require 它，它只加载一次。</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/requirejs/">requirejs</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-springmvc-permission" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/12/springmvc-permission/" class="article-date">
  	<time datetime="2015-05-12T13:47:39.000Z" itemprop="datePublished">2015-05-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/12/springmvc-permission/">基于Spring实现用户权限管理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>很多系统都会有多重系统角色，并且每个角色的权限都是不一样的，进行权限管理是一件非常复杂的事情，我这里只是对方法进行权限管理，将权限跟API一一对应起来，如果对这和API没有权限，就无法使用该API，当然这种方法级别的权限管理，范围还是太大，有待进一步细化。</p>
<p>具体的原理就是：<strong>使用权限码，假设我的使用的是128位的权限码，那都能设置128种方法的权限，如果需要更多，可以继续加。每一个API方法都对应唯一一个权限码，即当前位是1其余位都是0；每一个用户拥有一个128为的权限集，如果当前位对应1的话，就说明该用户可以操作这个API，否则就是无权限。</strong></p>
<h2 id="用户权限集"><a href="#用户权限集" class="headerlink" title="用户权限集"></a>用户权限集</h2><p>每个用户都拥有一个128位权限集，用两个long类型实现。</p>
<p>User.java</p>
<pre><code>@JsonIgnoreProperties(value = {&quot;permissionCodeHigh&quot;, &quot;permissionCodeLow&quot;})
public class User implements java.io.Serializable {

private static final long serialVersionUID = -5559386013177436565L;

private String id;                
private String name;            
private String email;        
private String address;        
private String permissionCode;  //权限代码 length = 128

// 省略getter和setter。。。。


private Long permissionCodeHigh;
private Long permissionCodeLow;

/**
 * 获取访问权限码高64位
 * @date 2015-1-4
 * @return
 */
public long getPermissionCodeHigh() {
    if (this.permissionCodeHigh == null) {
        synchronized(this) {
            if (this.permissionCode != null&amp;&amp; this.permissionCode.matches(&quot;^[0-1]{128}$&quot;)) {

                permissionCodeHigh = Long.parseLong(this.permissionCode.substring(0, 64), 2);
            } else {

                permissionCodeHigh = new Long(0);
            }
        }    
    }

    return this.permissionCodeHigh.longValue();
}

/**
 * 获取访问权限码低64位
 * @date 2015-1-4
 * @return
 */
public long getPermissionCodeLow() {
    if (this.permissionCodeLow == null) {            
        synchronized(this) {                
            if (this.permissionCode != null&amp;&amp; this.permissionCode.matches(&quot;^[0-1]{128}$&quot;)) {

                permissionCodeLow = Long.parseLong(this.permissionCode.substring(64), 2);
            } else {

                permissionCodeLow = new Long(0);
            }
        }
    }
    return this.permissionCodeLow.longValue();
}
</code></pre><h2 id="API权限码"><a href="#API权限码" class="headerlink" title="API权限码"></a>API权限码</h2><p>API方法的权限码是用注解定义的。首先定义一个权限码的注解：</p>
<pre><code>@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequiredPermission {

    long high() default 0;

    long low() default 0;
}
</code></pre><p>使用注解定义权限码</p>
<pre><code>@RequiredPermission（hight = 0,low = 1）
@RequestMapping(value = &quot;/api/{sessionid}/tables&quot;, method = RequestMethod.GET)
public @ResponseBody
ResultInfo&lt;List&lt;InnerControlTable&gt;&gt; get(@PathVariable(&quot;sessionid&quot;) String sessionID）
</code></pre><p>此方法对应的128为权限码就是 <strong>000000….0000(127个0)1</strong>，每一个方法只能允许一位是1，其余位都必须为0，这样128为的权限码可以为128个方法定义权限。</p>
<h2 id="拦截器处理"><a href="#拦截器处理" class="headerlink" title="拦截器处理"></a>拦截器处理</h2><p>获取当前用户的权限集，再获取访问方法的权限码，如果两者相与结果为0，说明待访问的方法的权限码不在用户的权限集里，因此没有权限访问。</p>
<pre><code>public class AuthorityInterceptor extends HandlerInterceptorAdapter {

    @Override
    public boolean preHandle(HttpServletRequest request,
            HttpServletResponse response, Object handler) throws Exception {

        String url = request.getServletPath();    
        RequiredPermission annotation ;
        try{
               HandlerMethod handlerMethod = (HandlerMethod) handler;
               Method method = handlerMethod.getMethod();
               annotation = method.getAnnotation(RequiredPermission.class);
        }catch(ClassCastException e){
                return true;
        }

        if (annotation != null) {

            //与用户权限代码比较，有一个如果不为0，则说明有相应的权限。
            if ((annotation.low() &amp; currUser.getPermissionCodeLow()) == 0 &amp;&amp;
                (annotation.high() &amp; currUser.getPermissionCodeHigh()) == 0) {

                //没有权限，返回错误。
                PrintWriter out = response.getWriter();
                out.print(JsonBinder.getInstance().toJson(ResultInfo.getIllegalPermission()));

                out.flush();
                out.close();

                return false;

            }

        }

    }

        return true;
    }
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/permission/">permission</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-springmvc-avoidduplicate" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/12/springmvc-avoidduplicate/" class="article-date">
  	<time datetime="2015-05-12T13:47:02.000Z" itemprop="datePublished">2015-05-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/12/springmvc-avoidduplicate/">防止表单重复提交</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>用表单进行文件上传的过程中，比较容易发生的就是重复提交，这样会造成很多无效的数据，为此，我的项目中加入了防止重复提交机制。防止重复提交的<strong>原理</strong>就是，在页面生成的时候，后台会为页面生成一个token，前端在上传的时候将token值传给后台，后台实现上传后就会销毁token,如果前端还是用token来上传，就会被判定是重复提交。具体步骤和实现如下：</p>
<h2 id="定义SpringMVC注解"><a href="#定义SpringMVC注解" class="headerlink" title="定义SpringMVC注解"></a>定义SpringMVC注解</h2><p>用注解实现后台防止重复提交的开关：</p>
<pre><code>/**
 * 
 * 防止重复提交注解，用于方法上
 * 在新建页面方法上，设置usingToken()为true，此时拦截器会在Session中保存一个token，
 * 同时需要在新建的页面中添加
 * &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;${token}&quot;&gt;
 * 保存方法需要验证重复提交的，设置needRemoveToken为true
 * 此时会在拦截器中验证是否重复提交
 * 
 * @author 王文路
 * @date 2015-1-9
 */

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AvoidDuplicateSubmission {
    boolean usingToken() default false;

}
</code></pre><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>在需要使用的上传接口上使用以上定义的注解，设置usingToken为<strong><font color="blue">true</font></strong>:</p>
<pre><code>@AvoidDuplicateSubmission(usingToken=true)
@RequestMapping(value = &quot;/api/{sessionid}/documents&quot;, method = RequestMethod.POST)
 public @ResponseBody
 ResultInfo&lt;List&lt;Document&gt;&gt; upload(@PathVariable(&quot;sessionid&quot;)String sessionID)
</code></pre><h2 id="生成Token"><a href="#生成Token" class="headerlink" title="生成Token"></a>生成Token</h2><p>在后台返回View的时候，生成Token，并且放在session中，可以让前端拿到token进行使用，后台代码：</p>
<pre><code>@Controller
public class MainViewController extends MultiActionController {

    @RequestMapping (value= &quot;mainview&quot;)
    public @ResponseBody
    ModelAndView main(HttpServletRequest request,
            HttpServletResponse response){
        String moduleid = request.getParameter(&quot;moduleid&quot;);

         String tokent = TokenHelper.getInstance().makeToken();
         request.getSession().setAttribute(&quot;token&quot;, tokent);

        HttpSession http_session = request.getSession();

        ModelAndView ret = new ModelAndView(&quot;main&quot;);
        ret.addObject(&quot;moduleid&quot;, moduleid);
        return  ret;
    }
}
</code></pre><h2 id="前端使用Token"><a href="#前端使用Token" class="headerlink" title="前端使用Token"></a>前端使用Token</h2><p>前端保留Token值</p>
<pre><code>String token =  request.getSession().getAttribute(&quot;token&quot;);
</code></pre><p>在上传的时候使用token</p>
<pre><code>&lt;form action=&quot;&quot;  enctype=&quot;multipart/form-data&quot; method= &quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;动态内容&quot; name =&quot;data&quot;&gt;
        &lt;input type=&quot;file&quot; name=&quot;files&quot; class=&quot;btn&quot; multiple style=&quot;display:block;&quot;&gt;
        &lt;input type=&quot;file&quot; name=&quot;token&quot; value=&quot;&lt;%=token%&gt;&quot;&gt;
        &lt;button type=&quot;button&quot; id=&quot;activty-person-publish-submit&quot; class=&quot;btn btn-primary&quot;&gt;发表&lt;/button&gt;
&lt;/form&gt;
</code></pre><h2 id="设置拦截器"><a href="#设置拦截器" class="headerlink" title="设置拦截器"></a>设置拦截器</h2><p>具体实现的处理方法还需要放在拦截器中去处理，拦截器能够拦截所有发向后台的HTTP请求，只要http请求对应的方法上使用了注解并且设置了</p>
<pre><code>usingToken = true
</code></pre><p>就进行处理。首先从前端参数中取出token，进行比对，看token是否已经失效，如果失效就判定是二次提交，直接拦截。</p>
<pre><code>/**
 *  防止重复提交过滤器
 * 
 * @author 王文路
 * @date 2015-1-9
 */
public class AvoidDuplicateSubmissionInterceptor extends HandlerInterceptorAdapter {

private static final Logger logger = Logger.getLogger(AvoidDuplicateSubmissionInterceptor.class);

@Override
public boolean preHandle(HttpServletRequest request,
        HttpServletResponse response, Object handler) throws Exception {

     AvoidDuplicateSubmission annotation;
    try{
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        Method method = handlerMethod.getMethod();

        annotation = method.getAnnotation(AvoidDuplicateSubmission.class);
    }catch(ClassCastException e){
        return true;
    }

        if (annotation != null) {
            boolean usingToken = annotation.usingToken();

            if (usingToken) {

                if (isRepeatSubmit(request)) {
                    logger.warn(&quot;不能重复提交请求,[url:&quot; + request.getServletPath() + &quot;]&quot;);
                    return false;
                }
                request.getSession().removeAttribute(&quot;token&quot;);
            }
        }

    return true;
}

private boolean isRepeatSubmit(HttpServletRequest request) {
    String serverToken = (String) request.getSession().getAttribute(&quot;token&quot;);
    if (serverToken == null) {
        return true;
    }
    String clinetToken = request.getParameter(&quot;token&quot;);
    if (clinetToken == null) {
        return true;
    }
    if (!serverToken.equals(clinetToken)) {
        return true;
    }
    return false;
}

}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-springmvc-filedownload" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/12/springmvc-filedownload/" class="article-date">
  	<time datetime="2015-05-12T04:47:22.000Z" itemprop="datePublished">2015-05-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/12/springmvc-filedownload/">SpringMVC实现文件下载</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>文件下载的时候要保证客户端弹出的保存框中的文件名不出现乱码，并且文件类型正确。</p>
<p>后台代码如下：</p>
<pre><code>@RequestMapping(value = &quot;/api/{sessionid}/documents/download/{documentid}&quot;)
public void download(@PathVariable(&quot;sessionid&quot;)String sessionID,
        @PathVariable(&quot;documentid&quot;)String docID,
        HttpServletRequest request,
        HttpServletResponse response) throws UnsupportedEncodingException{

    response.setCharacterEncoding(&quot;utf-8&quot;);
    request.setCharacterEncoding(&quot;utf-8&quot;);

    if ((docID == null || docID.length() == 0)) return;

    try{
        Document doc = docService.findByID(docID);

        if (doc == null) {
            return ;
        }

        String filepath = doc.getSavePath();
        String mimetype = doc.getMimeType();
        String fileName = doc.getFullName();

        if (filepath == null || filepath == &quot;&quot;) return;

        String str = fileName + &quot;.&quot; +StringUtils.getFilenameExtension(filepath);
        byte[] ss = str.getBytes(&quot;GBK&quot;);
        String filename = new String(ss,&quot;ISO_8859_1&quot;);

        //得到客服端输出的输出流  
        OutputStream outputStream = response.getOutputStream();
        //输出文件用的字节数组，每次向输出流发送600个字节  
        byte b[] = new byte[1024];  
        //要下载的文件  
        File fileload = new File(filepath);
        //客服端使用保存文件的对话框  

        response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot; + filename +&quot;&quot;);// URLEncoder.encode(filename, &quot;UTF-8&quot;));

        response.setContentType(mimetype);
        //通知客服文件的长度  
        long fileLength = fileload.length();  
        String length = String.valueOf(fileLength);  
        response.setHeader(&quot;Content_length&quot;, length);  
        //读取文件，并发送给客服端下载  
        FileInputStream inputStream = new FileInputStream(fileload);
        int n = 0;
        while ((n = inputStream.read(b)) != -1) {

            outputStream.write(b, 0, n);
        } 

        outputStream.flush();
        outputStream.close();

        inputStream.close();
    } catch(RuntimeException e){

        logger.error(e.getMessage(), e.fillInStackTrace());

    } catch(Exception e){

        logger.error(e.getMessage() , e.fillInStackTrace());
    }

}
</code></pre><p>以上通过对文件名编码，使得前端保存文件的对话框显示的文件名是正常的。</p>
<pre><code>byte[] ss = str.getBytes(&quot;GBK&quot;);
String filename = new String(ss,&quot;ISO_8859_1&quot;);

response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot; + filename +&quot;&quot;);
</code></pre><p>这里的乱码显示主要是由于中文造成的，将中文件进行如上的转码即可。</p>
<p>对于文件类型，如果知道文件类型，就如下声明文件类型：</p>
<pre><code>response.setContentType(mimetype);
</code></pre><p>如果不知道就设置成自动识别，不过不能保证对所有格式的文件都能正确识别：</p>
<pre><code>response.setContentType(&quot;multipart/form-data&quot;);
</code></pre><p>对于前台就非常简单了，只要向以上的api发送一个get请求即可，最简单的就是使用超链接：</p>
<pre><code>&lt;a href=&apos;api/&quot; + sessionId + &quot;/documents/download/&quot; + item.id+
                                &quot;&apos;&gt;&quot; + item.fullName +&quot;&lt;/a&gt;
</code></pre><p>保证href是文件下载的API，点击超链接的时候就会向这个api发送get请求，弹出保存文件的对话框（对于有些浏览器，比如Chrome就自动下载），实现文件下载。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/file/">file</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-springmvc-multipartfile" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/12/springmvc-multipartfile/" class="article-date">
  	<time datetime="2015-05-12T01:46:21.000Z" itemprop="datePublished">2015-05-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/12/springmvc-multipartfile/">基于MultipartFile实现多文件上传</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="用Spring下的MultipartFile实现多文件上传功能"><a href="#用Spring下的MultipartFile实现多文件上传功能" class="headerlink" title="用Spring下的MultipartFile实现多文件上传功能"></a>用Spring下的MultipartFile实现多文件上传功能</h2><p>Spring自带了多文件上传功能，主要是spring下的MultipartFile实现的，在实现多文件上传之前，要保证导入了Spring的包文件。以下是我的项目中导入Spring包。</p>
<p>pom.xml</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>在Spring中配置文件上传：</p>
<pre><code>&lt;!-- SpringMVC上传文件时，需要配置MultipartResolver处理器 --&gt;  
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;  
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;  
    &lt;!-- 指定所上传文件的总大小不能超过10M。注意maxUploadSize属性的限制不是针对单个文件，而是所有文件的容量之和 --&gt;  
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;  
&lt;/bean&gt;
</code></pre><p>文件上传后台处理：</p>
<pre><code>@RequestMapping(value = &quot;/api/{sessionid}/documents&quot;, method = RequestMethod.POST)
 public @ResponseBody
 ResultInfo&lt;String&gt; upload(@PathVariable(&quot;sessionid&quot;)String sessionID,
            @RequestParam(&quot;category&quot;)String category,
            HttpServletRequest request,
            HttpServletResponse response) throws IOException {

      ResultInfo&lt;String&gt; info = new ResultInfo&lt;String&gt;();

    try{

          MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;

          // 1 得到上传的文件
          List&lt;MultipartFile&gt; mFiles = multipartRequest.getFiles(&quot;files&quot;);

         for (MultipartFile mFile : mFiles) {

          if (mFile == null) {

              return ResultInfo.getIllegalDataAccess();
          }

          // 2 得到上传服务器的路径
          String path = request.getSession().getServletContext()
                    .getRealPath(&quot;/&quot;) +  &quot;..\\teworks-docs&quot;;

          // 新建文件目录
          File file = new File(path);
          if (!file.exists()) {
              file.mkdir();
          }

          // 3 得到上传的文件的文件名
          String filename = mFile.getOriginalFilename();

          InputStream inputStream = mFile.getInputStream();

          byte[] b = new byte[1048576];

          int length = inputStream.read(b);
          String docID = UUID.get();

          path += &quot;\\&quot; + docID + &quot;.&quot; + StringUtils.getFilenameExtension(filename);

          // 4文件流写到服务器端
          FileOutputStream outputStream = new FileOutputStream(path);

          // 5 保存document对象
          Document doc = new Document();
          doc.setId(docID);

          doc.setDocGroupID(category);

          if(dirID != null) {
              doc.setDocumentDirectory(this.docDirService.findByID(dirID));
          } 
          doc.setFileSize(length);
          doc.setFullName(DocumentHelper.getFileName(filename));
          doc.setMimeType(mFile.getContentType());
          Document ret = this.docService.add(doc);

          // 6 存储文件
          outputStream.write(b, 0, length);
          inputStream.close();
          outputStream.close();
        }

          // 7 返回结果
          info.setErrorCode(0);
          info.setResult(rets);

          return info;
    } catch(RuntimeException e){

        logger.error(e.getMessage(), e.fillInStackTrace());

    } catch (Exception e){
        logger.error(e.getMessage(), e.fillInStackTrace());
    }

      return ResultInfo.getIllegalDataAccess();
}
</code></pre><p>这里获取前台传过来的input的name必须是files，否则是获取不到文件参数的。<br>前台配置如下：</p>
<pre><code>&lt;form action=&quot;&quot;  enctype=&quot;multipart/form-data&quot; method= &quot;post&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;files&quot; class=&quot;btn&quot; multiple &gt;
    &lt;button type=&quot;button&quot; id=&quot;document-upload-submit&quot; class=&quot;btn btn-primary&quot;&gt;上传&lt;/button&gt;
&lt;/form&gt;
</code></pre><p>以上的type=“file”的input 中加入multiple则支持前台多选文件，这里的name必须为files，前后台要保持一次。</p>
<p>到这里为止，就能实现多文件上传了！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/file/">file</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-persist-pagination" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/11/persist-pagination/" class="article-date">
  	<time datetime="2015-05-11T13:59:53.000Z" itemprop="datePublished">2015-05-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/11/persist-pagination/">Hibernate和Mybatis的分页功能实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="持久层实现分页功能"><a href="#持久层实现分页功能" class="headerlink" title="持久层实现分页功能"></a>持久层实现分页功能</h2><p>分页功能在很多场合都会使用，比如如果有很多的资料，不分页的话网页效率将会堪忧， 用户体验也不好，分页功能有效缓解大数据的压力，这里所讲分页功能，主要是对数据库中的结构化数据而言的。</p>
<p>持久层框架我用过两种：<strong>Hibernate</strong> 和 <strong>Mybatis</strong> 。 这里将两种框架的分页功能进行实现。</p>
<h3 id="Hibernate分页"><a href="#Hibernate分页" class="headerlink" title="Hibernate分页"></a>Hibernate分页</h3><p>Hiberntae 分页比较简单，因为Hibernate自带了分页功能，直接进行配置即可：</p>
<pre><code>@Override
public ChannelTalkItem[] findByPage(final String channelID, final int startPos,
        final int pageCount) {
    List&lt;ChannelTalkItem&gt; itemList = this.getHibernateTemplate().execute(new HibernateCallback&lt;List&lt;ChannelTalkItem&gt;&gt;(){

        @Override
        public List&lt;ChannelTalkItem&gt; doInHibernate(Session session)
                throws HibernateException, SQLException {
            Query query = session.createQuery(&quot;from ChannelTalkItem c where c.channelID =:channelId order by c.talkTime asc&quot;);
            query.setString( &quot;channelId&quot;, channelID);
            query.setFirstResult(startPos);
            query.setMaxResults(pageCount);
            return query.list();
        }

    });
    ChannelTalkItem[] rets = new ChannelTalkItem[itemList.size()];
    itemList.toArray(rets);
    return rets;
}
</code></pre><p>只要设置一下第一条记录的位置，以及取出多少条数据即可。分别对应设置</p>
<pre><code>query.setFirstResult(startPos);
query.setMaxResults(pageCount);
</code></pre><h3 id="Mybatis实现分页功能"><a href="#Mybatis实现分页功能" class="headerlink" title="Mybatis实现分页功能"></a>Mybatis实现分页功能</h3><p>由于Mybatis不像Hibernate自带分页功能，所以必须进行sql分页，对于sql分页有很多种方式，比如用top , 我这里是使用数据库自带的<strong>ROW_NUMBER</strong>方法实现的：<br>mybatis的Mapper.xml部分如下：</p>
<pre><code> &lt;select id=&quot;findByUser&quot; resultMap=&quot;ChannelTalkItemResultMap&quot;&gt;
&lt;!--
  WARNING - @mbggenerated
  This element is automatically generated by MyBatis Generator, do not modify.
  This element was generated on Tue Mar 17 19:27:41 CST 2015.
--&gt;
select * from (
   select *,ROW_NUMBER() OVER (order by TalkTime asc) as rank from ChannelTalkItem 
   where ChannelID = #{0} 
        and TalkerID = #{1} 
)  as c where c.rank between #{2} and #{3} 
  &lt;/select&gt;
</code></pre><p>原理就是在取出结果的时候，插入一列行序号，在进行编号的时候可以定义按表的哪一列进行排序，这里是按照 <strong><em>TaskTime</em></strong>升序进行编号，然后在where条件里筛选行编号即可。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hibernate/">hibernate</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-mybatis-using-brief" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/10/mybatis-using-brief/" class="article-date">
  	<time datetime="2015-05-10T06:17:46.000Z" itemprop="datePublished">2015-05-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/10/mybatis-using-brief/">持久框架Mybatis的应用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于持久层框架，我们比较熟悉的是Hibernate，这是一款功能非常强大的持久框。除此之外，还有一款比较流行的框架 - <strong>Mybatis</strong></p>
<h3 id="什么是Mybatis？"><a href="#什么是Mybatis？" class="headerlink" title="什么是Mybatis？"></a>什么是Mybatis？</h3><p>mybatis是数据映射器（数据映射器层：用于在对象和数据库之间搬运数据，同时保证对象、数据库和数据映射器层本身相对独立。Martin Fowler 《企业应用架构模式》） mybatis不是直接把类映射为数据库表，而是把sql语句的参数与结果（即输入与输出）映射为类。为如何在类和数据库间建立映射带来了更大的灵活性。同时也更好的隔离了数据库设计和应用程序中使用的对象模型。</p>
<p>从以上描述上可以很容易的看出Mybatis是将结果集映射成类，这种半自动化持久框架的最大特点就是具有很强的灵活性。何为半自动化，就是相对于Hibernate的全自动而言的，因为Mybatis需要为每一个持久层的接口定义一个sql语句，接口的执行，就是执行这些sql，每一个持久层方法都需要手动设置sql语句，所以更加灵活</p>
<p>对于Mybatis更多的介绍请参阅<a href="http://limingnihao.iteye.com/" title="黎明你好的技术博客" target="_blank" rel="external">黎明你好的技术博客</a>博主的博客<a href="http://limingnihao.iteye.com/blog/781671" title="Mybatis 的讲解" target="_blank" rel="external">http://limingnihao.iteye.com/blog/781671</a>，比较基础和详细。</p>
<p>可以看出mybatis持久框架主要涉及到了三个类，分别是Model模型，是要将结果集映射成的数据模型，Mapper 接口文件，对应持久层的接口；还有一个xml配置文件，用sql语句实现Mapper的接口。以下给出三种文件的例子：</p>
<p>Domain.java</p>
<pre><code>  public class Domain {

    private String id;
    private String name;
    private String domainCode; // 

    // 省略getter setter
}
</code></pre><p>DomainMapper.java:</p>
<pre><code>public interface DomainMapper {

public Domain findByID(String domainID);

public List&lt;Domain&gt; findAll();

public void add(Domain domain);

public void merge(Domain domain);

public void delete(String domainID);

}
</code></pre><p>DomainMapper.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;  
&lt;mapper namespace=&quot;com.test.pojo.domain.DomainMapper&quot;&gt;  

&lt;resultMap type=&quot;Domain&quot; id=&quot;DomainResultMap&quot;&gt;  
    &lt;id property=&quot;id&quot; column=&quot;ID&quot;/ jdbctype=VARCHAR&gt;  
    &lt;result property=&quot;name&quot; column=&quot;Name&quot;/ jdbctype=VARCHAR&gt; 
    &lt;result property=&quot;domainCode&quot; column=&quot;DomainCode&quot;/ jdbctype=VARCHAR&gt;  
&lt;/resultMap&gt;  

&lt;!-- 查询域，根据id --&gt;  
&lt;select id=&quot;findByID&quot; parameterType=&quot;String&quot; resultMap=&quot;DomainResultMap&quot;&gt;  
    &lt;![CDATA[ 
        SELECT * from Domain D 
            WHERE D.ID = #{doaminID}  
    ]]&gt;   
&lt;/select&gt;  

&lt;select id=&quot;findAll&quot; resultMap=&quot;DomainResultMap&quot;&gt;
    &lt;![CDATA[
        SELECT * from Domain
    ]]&gt;
&lt;/select&gt;

&lt;insert id=&quot;add&quot; parameterType=&quot;Domain&quot;&gt;  
    &lt;![CDATA[
        INSERT INTO DOMAIN         (ID,  
                                 NAME, DomainCode)  
          VALUES   (  #{id},  
                      #{name}, #{domainCode})  
    ]]&gt;
&lt;/insert&gt;  

&lt;update id=&quot;merge&quot; parameterType=&quot;Domain&quot;&gt;
    &lt;![CDATA[
        UPDATE DOMAIN
            SET NAME = #{name}
            WHERE ID = #{id}
    ]]&gt;
&lt;/update&gt;

&lt;delete id=&quot;delete&quot; parameterType=&quot;String&quot;&gt;
    &lt;![CDATA[
        DELETE DOMAIN
            WHERE ID = #{domainID}
    ]]&gt;
&lt;/delete&gt;

&lt;/mapper&gt; 
</code></pre><p>[CDATA]是保证里面的内容当成语句执行，可以不加，不加的时候注意一些关键字，比如User ，要写成‘User’格式</p>
<p>Mapper.java与Mapper.xml的方法一一对应，而且方法名必须一致<br>namespace指向Mapper.java文件，resultMap 是结果集映射，type是映射到的实体类，这里之所以没有写全路径，是因为Mybatis配置文件里可以对实体类定义别名。</p>
<p>mybatis-config.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;  
&lt;configuration&gt;  
&lt;typeAliases&gt;  
    &lt;typeAlias alias=&quot;Domain&quot; type=&quot;com.shenj.teworks.pojo.domain.Domain&quot;/&gt;  
  &lt;/typeAliases&gt;  
&lt;mappers&gt;  
    &lt;mapper resource=&quot;com/shenj/teworks/pojo/domain/DomainMapper.xml&quot; /&gt;
 &lt;/mappers&gt;  
&lt;/configuration&gt; 
</code></pre><p>所有的Mapper.xml文件都要在上面这个文件做一个声明；</p>
<p>在spring中定义datasource:</p>
<pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;net.sourceforge.jtds.jdbc.Driver&quot;&gt;
    &lt;/property&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:jtds:sqlserver://localhost:1433/Test&quot;&gt;
    &lt;/property&gt;
    &lt;property name=&quot;username&quot; value=&quot;sa&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;password&quot; value=&quot;sa&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>然后Mapper就可以在Spring里声明了，持久层接口就实现了。</p>
<p>应用Mybatis，最经常出现问题的就是xml配置文件：</p>
<p>ResultType取值<br>可以是一个对象，或者基本类型如，java.lang.Strin,java.lang.Integer<br>JDBCType是字段对应的数据库类型，取值如下：<br>BIT,NVACHAR,BIT,TIMESTAMP…</p>
<p>注意</p>
<ol>
<li>对于可能为空的字段，进行赋值的时候必须指明jdbcType</li>
<li>对于有些数据库的nvarchar类型，jdbcType指定为NVARCHAR会报错，请改为VARCHAR即可</li>
</ol>
<p>Mapper参数设置：<br>如果只有一个参数，可以这样赋值</p>
<pre><code>ID = #{id , jdbcType=VARCHAR}
</code></pre><p>或者使用编号，代表第几个参数</p>
<pre><code>ID = #{0}
</code></pre><p>如果存在不同类型的参数，在xml方法里就不能指明parameterType,<br>设置参数的时候有两种选择</p>
<p>1 接口</p>
<pre><code>pulic User find(Strig id , String year);
</code></pre><p>xml中使用序号获取参数 如</p>
<pre><code>where ID = #{0} and Year = #{1}
</code></pre><p>2 map,在server中将所有参数，封装成map<br>接口如下：</p>
<pre><code>public User find(Map map);

Map map = new Map();
map.set(&quot;id&quot;, id);
map.set(&quot;year&quot; ,year);
</code></pre><p>在xml中使用的时候直接用key</p>
<pre><code>where ID = #{id} and
Year = #{year}
</code></pre><p>此处名称id，year就是map设置的key，必须保持一致</p>
<h2 id="association"><a href="#association" class="headerlink" title="association:"></a>association:</h2><p>外键映射成对象，比如Schedule 表中有外键Creator 连接到表User表， Schedule对象中有User类型的creator属性，此时就要用association.<br>有两种方法：</p>
<p>1.用select  ，如下</p>
<pre><code>&lt;association property=&quot;creator&quot; column=&quot;Creator&quot; javaType=&quot;User&quot;  
        select=&quot;com.test.pojo.user.UserMapper.findByI    D&quot;/&gt; 
</code></pre><p>此时在获取Schedule对象的时候，根据外键Creator调用userMapper的select方法（UserMapper里事先已经实现了该方法），相当于再去User表中查询一次。</p>
<p>2.用resultMap,如下</p>
<pre><code>&lt;association property=&quot;creator&quot; column=&quot;Creator&quot; javaType=&quot;User&quot;  
        resultMap=&quot;com.test.pojo.user.UserMapper.UserResultMap&quot;/&gt; 
</code></pre><p>此时相当于把UserResultMap集成到ScheduleResulMap中，然后在获取的时候 将两张表连接在一起(此处保证UserMapper下的UserResultMap已经定义了)</p>
<pre><code>select * from Schedule left join User on Creator = UserID
</code></pre><p>在此需要保证Schedule和User的字段都不一样，否则ResultMap也不知道究竟映射哪一个了，第一种方法没有这种要求</p>
<p>从速度上来说，第一种方法做了两次查询，后一种方法只做了一次查询，因此速度更快，不过一定要保证两张表的字段不能重复，如果不能保证，还是保险一点使用第一种方法吧，如果对于性能要求比较高，再进行优化。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>当处理一对多关系时，映射的是一个关系表中的数据集合，跟association一样，也有两种方法</p>
<p>1.用select</p>
<pre><code>&lt;collection property=&quot;appointmentParticipants&quot; column=&quot;ID&quot; ofType=&quot;User&quot;
      select=&quot;com.test.pojo.schedule.AppointmentParticipantMapper.findParticipantByAppointment&quot;&gt;
    &lt;/collection&gt;
</code></pre><p>同理，进行两次查询， 只不过这个查询的结果是一个集合，通过ofType制定元素的类型</p>
<p>2.用ResultMap</p>
<pre><code>&lt;collection property=&quot;appointmentParticipants&quot; column=&quot;ID&quot; ofType=&quot;User&quot;
      ResultMap=&quot;com.test.pojo.schedule.AppointmentParticipantMapper.UserResultMap&quot;&gt;
    &lt;/collection&gt;
</code></pre><p>表连接的方式进行一次查询。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mybatis/">mybatis</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-octopress-using" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/09/octopress-using/" class="article-date">
  	<time datetime="2015-05-09T10:21:41.000Z" itemprop="datePublished">2015-05-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/09/octopress-using/">基于octopress与github搭建个人博客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>以下感谢<a href="http://jiehu5114.gitcafe.io/blog/2015/03/21/ji-yu-octopressyu-githubda-jian-ge-ren-bo-ke/" target="_blank" rel="external">胡杰的技术博客</a> 和 <a href="http://812lcl.com/blog/2013/10/26/octopressce-bian-lan-ji-ping-lun-xi-tong-ding-zhi/" target="_blank" rel="external">812lcl的博客</a>的技术支持！</strong></p>
<ul>
<li>安装Ruby</li>
<li><p>首先要在本地安装好Ruby环境，幸运的是OS X系统默认的已经可以运行Ruby了，因此我们只需要执行以下命令查看当前Ruby的版本.（如果未安装请<a href="http://octopress.org/docs/setup/rvm/" target="_blank" rel="external">参考ruby</a>）</p>
<p>  ruby –version</p>
</li>
</ul>
<ul>
<li>安装git</li>
<li><p>确保电脑安装有git,在终端输入如下命令。（如果未安装请<a href="http://git-scm.com/" target="_blank" rel="external">参考git</a>）</p>
<p>  git –version</p>
</li>
</ul>
<ul>
<li>安装Octopress</li>
<li><p>在终端输入如下命令</p>
<p>  git clone git://github.com/imathis/octopress.git octopress<br>  cd octopress<br>  gem install bundler<br>  bundle install</p>
</li>
</ul>
<ul>
<li><p>安装Octopress默认主题</p>
<p>  rake install</p>
</li>
</ul>
<p>如果不想安装默认主题，可以设置其他主题</p>
<ul>
<li>安装其他主题</li>
</ul>
<p>首先找到这个主题的github地址，比如我这个博客用的主题是<a href="https://github.com/bkutil/bootstrap-theme.git" target="_blank" rel="external">https://github.com/bkutil/bootstrap-theme.git</a>,然后用git的clone方法把它下载到你本地博客的根目录的.themes文件夹中：</p>
<pre><code>git clone https://github.com/bkutil/bootstrap-theme.git ./.themes/bootstrap-theme
</code></pre><p>下完之后你会发现在.themes文件夹下多了一个bootstrap-theme文件夹，这就是主题，然后进行安装，执行</p>
<pre><code>rake install [&apos;bootstrap-theme&apos;]
</code></pre><ul>
<li>部署到github</li>
<li></li>
<li>配置github</li>
</ul>
<p>首先需要在GitHub上创建一个仓库，并将仓库名称按照这样的方式进行命名：your_username.github.io。然后在终端输入如下命令，期间会要求你输入仓库的url，根据提示输入即可，格式如:git@github.com:your_username/your_username.github.io.git</p>
<pre><code>rake setup_github_pages
</code></pre><p>生成html静态网页<br>在终端输入如下命令.</p>
<pre><code>rake generate
</code></pre><p>部署到github服务器<br>在终端输入如下命令.</p>
<pre><code>rake deploy
</code></pre><ul>
<li>部署到gitcafe<br>-</li>
</ul>
<p>对于Octopress，我们只需要每次提交网站内容时，执行完 rake deploy之后，再执行以下脚本即可（你可以将该脚本中的代码仓库地址换成你的，然后将其保存成一个脚 本文件，需要时执行一下即可）：</p>
<pre><code>cd _deploy
</code></pre><h3 id="添加-gitcafe-源"><a href="#添加-gitcafe-源" class="headerlink" title="添加 gitcafe 源"></a>添加 gitcafe 源</h3><pre><code>git remote add gitcafe git@gitcafe.com:vence/vence.git &gt;&gt; /dev/null 2&gt;&amp;1
</code></pre><h3 id="提交博客内容"><a href="#提交博客内容" class="headerlink" title="提交博客内容"></a>提交博客内容</h3><pre><code>echo &quot;### Pushing to GitCafe...&quot;
git push -u gitcafe master:gitcafe-pages
echo &quot;### Done&quot;%
</code></pre><p>大概解释一下以上内容，Octopress在发布时会将自己的 _delpoy目录切换到master分支，然后将生成的博客内容放到_delpoy目录中，然后执行git push操作。正常情况下，默认内容是push到github上的。我们执行的以上脚本，就是为该项目增加了一个名为gitcafe的远程仓库，然后将master分支push到gitcafe的gitcafe-pages分支。</p>
<ul>
<li>写博客</li>
<li><p>Octopress为我们提供了一些task来创建博文和页面。博文必须存储在source/_posts目录下，并且需要按照Jekyll的命名规范对文章进行命名：YYYY-MM-DD-post-title.markdown。文章的名字会被当做url的一部分，而其中的日期用于对博文的区分和排序。</p>
<p>  rake new_post[“title”]<br>  rake generate<br>  rake deploy</p>
</li>
</ul>
<ul>
<li>插件</li>
<li></li>
<li><p>评论和分享：友言和加网</p>
</li>
</ul>
<p>octopress内置了disqus评论系统，不适合我国基本国情，所以需要用一些国内的第三 方评论系统，如友言、多说，可以以微博、人人、QQ等账号登陆发表评论，网站通过 验证后可以对评论进行分析，管理。</p>
<p>多说评论系统可参见为 Octopress 添加多说评论系统，不多做介绍。</p>
<p>我主要使用的是<a href="http://www.uyan.cc/" target="_blank" rel="external">友言</a>的一套评论系统及插件]，分享使用的是加网JiaThis。首先注册 友言账号，否则无法进行后台管理。注册之后获得代码， 添加到source/_includes/post/share_comment.html。 <a href="http://www.jiathis.com/getcode/icon" target="_blank" rel="external">加网点击这里</a>，定制自己喜欢的样式， 获得代码也添加到上述文件中。</p>
<p>share_comment.html文件中代码如下（每个人不同）：</p>
<pre><code>&lt;!-- JiaThis BEGIN --&gt;
&lt;div class=&quot;jiathis_style_32x32&quot;&gt;
        &lt;a class=&quot;jiathis_button_qzone&quot;&gt;&lt;/a&gt;
        &lt;a class=&quot;jiathis_button_tsina&quot;&gt;&lt;/a&gt;
        &lt;a class=&quot;jiathis_button_tqq&quot;&gt;&lt;/a&gt;
        &lt;a class=&quot;jiathis_button_weixin&quot;&gt;&lt;/a&gt;
        &lt;a class=&quot;jiathis_button_renren&quot;&gt;&lt;/a&gt;
        &lt;a href=&quot;http://www.jiathis.com/share?uid=1850190&quot; class=&quot;jiathis jiathis_txt jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;
        &lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://v3.jiathis.com/code/jia.js?uid=1361705530382241&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;!-- JiaThis END --&gt;

&lt;!-- Baidu Button BEGIN 
&lt;div id=&quot;bdshare&quot; class=&quot;bdshare_t bds_tools_32 get-codes-bdshare&quot;&gt;
        &lt;a class=&quot;bds_tsina&quot;&gt;&lt;/a&gt;
        &lt;a class=&quot;bds_qzone&quot;&gt;&lt;/a&gt;
        &lt;a class=&quot;bds_tqq&quot;&gt;&lt;/a&gt;
        &lt;a class=&quot;bds_renren&quot;&gt;&lt;/a&gt;
        &lt;a class=&quot;bds_t163&quot;&gt;&lt;/a&gt;
        &lt;a class=&quot;bds_hi&quot;&gt;&lt;/a&gt;
        &lt;span class=&quot;bds_more&quot;&gt;&lt;/span&gt;
        &lt;a class=&quot;shareCount&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; id=&quot;bdshare_js&quot; data=&quot;type=tools&amp;amp;uid=6839808&quot; &gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; id=&quot;bdshell_js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
        document.getElementById(&quot;bdshell_js&quot;).src = &quot;http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=&quot; + Math.ceil(new Date()/3600000)
&lt;/script&gt;
 Baidu Button END --&gt;

&lt;!-- UY BEGIN --&gt;
&lt;div id=&quot;uyan_frame&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://v2.uyan.cc/code/uyan.js?uid=1850190&quot;&gt;&lt;/script&gt;
&lt;!-- UY END --&gt;
</code></pre><p>其中有一段代码注释掉了，那是曾经添加的百度分享的代码，如果使用其他分享或 评论，代码也可以添加到这。</p>
<p>现在功能代码在share_comment.html中了，下面需要使其显示到博文的底部。</p>
<p>首先在_config.yml中添加开关：</p>
<pre><code># comment and share
comment_share: true
</code></pre><p>然后在source/_includes/post/sharing.html中添加如下代码(请自行将下列代码中的”{“ 和 “}” 改成半角)：</p>
<pre><code>｛% if site.comment_share %｝
    ｛% include post/share_comment.html %｝      
｛% endif %｝
</code></pre><p>最后需要使你的网站通过友言的验证，才可以进行后台管理，后台可以进行评论管理、 社交影响力分析、和评论栏的风格功能设置。</p>
<p>其余插件请参考原文<a href="http://812lcl.com/blog/2013/10/26/octopressce-bian-lan-ji-ping-lun-xi-tong-ding-zhi/" target="_blank" rel="external">http://812lcl.com/blog/2013/10/26/octopressce-bian-lan-ji-ping-lun-xi-tong-ding-zhi/</a>,在此感谢博主<a href="http://812lcl.com/" target="_blank" rel="external">812lcl的博客</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blog/">blog</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/octopress/">octopress</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 王文路
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>